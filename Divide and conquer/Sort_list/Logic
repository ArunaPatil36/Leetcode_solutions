LeetCode Problem Summary: Sort List (Problem #148)
Problem ID: 148. Sort List

Question
Sort a singly linked list in O(n log n) time with O(1) space complexity (excluding recursion stack).
Constraints:
	â€¢ 0 <= List.length <= 5 * 10^4
	â€¢ -10^5 <= Node.val <= 10^5

Solution
Approach: Merge Sort (Recursive)
Time Complexity: O(n log n)
Space Complexity: O(log n) (recursion stack depth for balanced tree) â€” accepted as "constant" per problem constraints.

Key Insight
	â€¢ Divide-and-Conquer:
		1. Split the list into two halves (using slow/fast pointers).
		2. Recursively sort both halves.
		3. Merge the sorted halves (using the merge function from the previous example).
	â€¢ Why Merge Sort?
		â—‹ Optimal for linked lists (avoids random access needed for quicksort).
		â—‹ Naturally splits the list without extra space (except recursion stack).

Corrected Code
class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) return head;
        
        // Split list into two halves
        ListNode slow = head, fast = head, prev = null;
        while (fast != null && fast.next != null) {
            prev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }
        prev.next = null; // Cut the list at middle
        
        // Recursively sort both halves
        ListNode left = sortList(head);
        ListNode right = sortList(slow);
        
        // Merge sorted halves
        return merge(left, right);
    }
    
    private ListNode merge(ListNode left, ListNode right) {
        if (left == null) return right;
        if (right == null) return left;
        
        if (left.val < right.val) {
            left.next = merge(left.next, right);
            return left;
        } else {
            right.next = merge(left, right.next);
            return right;
        }
    }
}
Apply Code

Simple Explanation
	1. Base Case: If list has 0 or 1 node, it's sorted.
	2. Split:
		â—‹ Use slow/fast pointers to find the middle node.
		â—‹ Split the list into left (head to middle) and right (middle+1 to end).
	3. Recursion:
		â—‹ Sort left and right halves recursively.
	4. Merge:
		â—‹ Combine sorted halves (like merging two sorted arrays) using the merge function.
		â—‹ Example: 1â†’3â†’5 + 2â†’4â†’6 â†’ 1â†’2â†’3â†’4â†’5â†’6.

Alternative Approach
Iterative (Bottom-Up) Merge Sort
	â€¢ How it works:
		â—‹ Start with sublists of size 1, merge adjacent pairs, double size each iteration.
		â—‹ Uses dummy head and no recursion (O(1) space excluding input).
	â€¢ Why consider it?
		â—‹ Avoids recursion stack (O(1) space vs. O(log n) for recursive).
		â—‹ More complex to implement but avoids stack overflow for very long lists.
	â€¢ Trade-off:
		â—‹ Recursive: Simpler, readable, O(log n) space (accepted).
		â—‹ Iterative: More efficient in space (O(1)), but harder to debug.

Optimized Approach?
No optimization exists for time complexity (O(n log n) is optimal for comparison-based sort).
	â€¢ Recursive solution is the standard and recommended approach for this problem.
	â€¢ Why not other sorts?
		â—‹ Quicksort: Worst-case O(nÂ²), requires random access (inefficient for linked lists).
		â—‹ Heapsort: O(n log n) time but O(n) space for heap (not O(1)).
	ðŸ’¡ Key Takeaway:
	The recursive merge sort is the optimal solution for LeetCode 148. The iterative approach is an alternative but not "optimized" â€” it trades readability for slightly lower space usage.

Interview Questions & Answers
Question	Answer
Why merge sort?	Itâ€™s O(n log n) time, stable, and works efficiently with linked lists (no random access).
Why not quicksort?	Quicksort has O(nÂ²) worst-case time and needs random access (linked lists donâ€™t support it).
How do you split the list?	Use slow/fast pointers (fast moves twice as fast as slow â†’ slow stops at middle).
Whatâ€™s the space complexity?	O(log n) for recursion stack (accepted as "constant" per problem constraints).
Can we do O(1) space?	Yes, with iterative merge sort, but itâ€™s more complex. Recursive is preferred for clarity.
Why not convert to array?	That would use O(n) extra space (violates problem constraints).

Why This Solution Dominates
	1. Correct: Produces a fully sorted linked list.
	2. Efficient: O(n log n) time (optimal for comparison-based sort).
	3. Standard: Matches LeetCodeâ€™s official solution and interview expectations.
	4. Readable: Recursive structure mirrors the problemâ€™s natural divide-and-conquer logic.
	âœ… Final Verdict:
	Recursive merge sort is the only practical solution for this problem. The iterative approach is an academic alternative but not required for interviews or LeetCode.

From <https://leetcode.com/problems/sort-list/?envType=study-plan-v2&envId=top-interview-150> 




Merge function:
Here's a simple, step-by-step explanation of the merge function using a concrete example:

Problem
Merge two sorted linked lists into one sorted linked list (like merging two halves in merge sort).

Example
	â€¢ left = 1 â†’ 3 â†’ 5
	â€¢ right = 2 â†’ 4 â†’ 6
Goal: Merge into 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6

How the Code Works
(Step-by-step with the example)
Step 1: Compare heads
	â€¢ left.val = 1, right.val = 2
	â€¢ 1 < 2 â†’ left becomes the new head
left.next = merge(left.next, right); 
// left.next = merge(3â†’5, 2â†’4â†’6)
Apply Code
Step 2: Recursive call
Now merge left = 3â†’5 and right = 2â†’4â†’6
	â€¢ Compare 3 and 2 â†’ 2 < 3 â†’ right becomes next
right.next = merge(left, right.next); 
// right.next = merge(3â†’5, 4â†’6)
Apply Code
Step 3: Recursive call again
Now merge left = 3â†’5 and right = 4â†’6
	â€¢ Compare 3 and 4 â†’ 3 < 4 â†’ left becomes next
left.next = merge(left.next, right); 
// left.next = merge(5, 4â†’6)
Apply Code
Step 4: Recursive call again
Now merge left = 5 and right = 4â†’6
	â€¢ Compare 5 and 4 â†’ 4 < 5 â†’ right becomes next
right.next = merge(left, right.next); 
// right.next = merge(5, 6)
Apply Code
Step 5: Base case
Merge left = 5 and right = 6
	â€¢ 5 < 6 â†’ left becomes head, left.next = right
// Returns 5 â†’ 6
Apply Code

Result
The recursion builds the merged list backwards:
	1. 5 â†’ 6
	2. 4 â†’ (5 â†’ 6) â†’ 4 â†’ 5 â†’ 6
	3. 3 â†’ (4 â†’ 5 â†’ 6) â†’ 3 â†’ 4 â†’ 5 â†’ 6
	4. 2 â†’ (3 â†’ 4 â†’ 5 â†’ 6) â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6
	5. 1 â†’ (2 â†’ 3 â†’ 4 â†’ 5 â†’ 6) â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6

Why It Works
	â€¢ Base cases handle empty lists.
	â€¢ Recursive step picks the smaller head and links it to the merged rest of the lists.
	â€¢ No new nodes are createdâ€”it reuses existing nodes by reassigning next pointers.
	â€¢ Time Complexity: O(n + m) (where n and m are list lengths).

Key Insight
	ðŸ”„ The recursion "peels off" the smallest remaining element at each step, building the merged list from head to tail.
	(Itâ€™s like picking the smallest card from two piles and placing it on the table, then repeating.)

Visual Summary
left: 1 â†’ 3 â†’ 5
right: 2 â†’ 4 â†’ 6

Step 1: 1 (smallest) â†’ merge(3â†’5, 2â†’4â†’6)
Step 2: 2 (smallest) â†’ merge(3â†’5, 4â†’6)
Step 3: 3 (smallest) â†’ merge(5, 4â†’6)
Step 4: 4 (smallest) â†’ merge(5, 6)
Step 5: 5 (smallest) â†’ 6
Final: 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6 âœ…

Common Mistake to Avoid
âŒ Creating new nodes (e.g., new ListNode(val)) â†’ Wastes space.
âœ… Reusing existing nodes (by reassigning next) â†’ O(1) extra space (except recursion stack).
This is the standard way to merge linked lists in merge sort! ðŸŒŸ

From <https://leetcode.com/problems/sort-list/?envType=study-plan-v2&envId=top-interview-150> 
